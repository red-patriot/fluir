import copy
from dataclasses import dataclass
from typing import Literal, cast, override

from pydantic import BaseModel

from editor.models import Program, QualifiedID, elements
from editor.models.edit_errors import BadEdit
from editor.models.elements import find_element
from editor.models.id import make_qualified_id
from editor.services.transaction.base import TransactionBase
from editor.services.transaction.remove import RemoveItem
from editor.utility.next_id import next_id


class AddConduit(BaseModel, TransactionBase):
    discriminator: Literal["add_conduit"] = "add_conduit"
    source: str  # "input-QualifiedID-index"
    target: str  # "output-QualifiedID-index"
    added: QualifiedID | None = None
    previous: elements.Conduit | None = None

    @dataclass
    class InOutID:
        id: QualifiedID
        index: int

    @override
    def do(self, original: Program) -> Program:
        # Parse the source and target strings to get the IDs and indices
        source_parts = self.source.split("-")
        target_parts = self.target.split("-")
        if len(source_parts) != 3 or len(target_parts) != 3:
            raise BadEdit("Invalid source or target format for conduit")
        source_id = self.InOutID(
            id=make_qualified_id(source_parts[1]),
            index=int(source_parts[2]),
        )
        target_id = self.InOutID(
            id=make_qualified_id(target_parts[1]),
            index=int(target_parts[2]),
        )

        # Create a conduit and add it to the program
        if source_id.id[:-1] != target_id.id[:-1]:
            # TODO: Handle this better
            raise BadEdit("Source and target must be in the same function")

        decl = find_element(source_id.id[:-1], original)
        if not isinstance(decl, elements.Function):
            # TODO: Handle other types of decls better
            raise BadEdit("Source must be a function to add a conduit")

        if existing_conduit := next(
            (
                conduit
                for conduit in decl.conduits
                if len(conduit.children) > 0
                and isinstance(conduit.children[0], elements.Conduit.Output)
                and conduit.children[0].target == target_id.id[-1]
                and conduit.children[0].index == target_id.index
            ),
            None,
        ):
            self.previous = copy.deepcopy(existing_conduit)
            self.added = source_id.id[:-1] + [self.previous.id]
            # If a conduit already exists, we reset the source
            existing_conduit.input = source_id.id[-1]
            existing_conduit.index = source_id.index
            return original

        self.added = source_id.id[:-1] + [
            next_id(decl)
        ]  # ID should be generated by the system
        decl.conduits.append(
            elements.Conduit(
                id=self.added[-1],
                input=source_id.id[-1],
                index=source_id.index,
                children=[
                    elements.Conduit.Output(
                        target=target_id.id[-1], index=target_id.index
                    )
                ],
            )
        )

        return original

    @override
    def undo(self, original: Program) -> Program:
        assert self.added is not None
        RemoveItem(target=self.added).do(original)
        if self.previous is not None:
            source_id = self._create_inout_id(self.source)
            decl = cast(
                elements.Function, find_element(source_id.id[:-1], original)
            )
            decl.conduits.append(self.previous)
        return original

    def _create_inout_id(self, description: str) -> InOutID:
        parts = description.split("-")
        if len(parts) != 3:
            raise BadEdit("Invalid source or target format for conduit")
        id = self.InOutID(
            id=make_qualified_id(parts[1]),
            index=int(parts[2]),
        )
        return id
